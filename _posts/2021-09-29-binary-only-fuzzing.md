---
title: "Breaking Through Binaries: Compiler-quality Instrumentation for Better Binary-only Fuzzing"
author: Team Group Hot Source
categories: [Fuzzing]
tags: [Fuzzing, Binary Only, Instrumentation]
pin: true
---

## Paper Info
- **Paper Name**: Breaking Through Binaries: Compiler-quality Instrumentation for Better Binary-only Fuzzing
- **Conference**: USENIX Security '21
- **Author List**: Stefan Nagy, Anh Nguyen-Tuong, Jason D. Hiser, Jack W. Davidson, Matthew Hicks
- **Link to Paper**: [here](https://www.usenix.org/conference/usenixsecurity21/presentation/nagy)
- **Food**: No food

## Prerequisites

## Background

## Solution

### ZAFL

The primary contribution (and scientific solution) presented by this paper is a platform (ZAFL: Zipr-based AFL) that enables one to apply compiler-only fuzzing techniques to a binary-only target via static rewriting in a stable and useable manner. Any other techniques implemented by the authors in this paper are based on previous work done in other fuzzing and binary-instrumentation papers. ZAFL implements the four design principles discussed above via two primary components, a static rewriting engine that the authors extended from Zipr; and ZAX, a set of four IR-modifying phases that integrates both compiler-quality instrumentation and various fuzzing enhancements.

![](/assets/img/2021-09-29-binary-only-fuzzing/zafl-pipeline.png)

As seen in pipeline above, ZAFL functions by extracting an IR of the target binary via their extension of Zipr, then processing it through the ZAX platform's four transformations (Optimization, Transformation, Point Selection and Application). This creates a modified, instrumented IR that can be fuzzed as though it were generated by a compiler-based target instead of a binary-only target.

Using modified IR built on the ZAX archicture, ZAFL enables any user to create and deploy program transformations/optimizations that were previously limited to compiler-based approaches to improve fuzzing performance on binary-only targets. As a demonstration of the effectiveness of ZAFL, the authors implemented 3 performance-enhancing and 2 feedback-enhancing compiler-based transformations via ZAX. These 'qualitative upgrades' were selected over other transformations as the most effective/impactful compiler optimization techniques, based on the authors' own observations.

![](/assets/img/2021-09-29-binary-only-fuzzing/fuzzing-enhancements.png)

(TODO: breakdown of the techniques? seems unnecessary)

A short video demo of ZAFL in action can be seen here (TODO: link to snip of Zions' demo)

### Evaluation

The authors evaluate ZAFL against two other fuzzing tools, AFL-Dynist and AFL-QEMU, on the LAVA-M benchmark and on 8 real-world open-source program binaries. Overall, ZAFL finds more crashes in both the LAVA-M benchmark and real-world binaries.

![](/assets/img/2021-09-29-binary-only-fuzzing/lava-m-eval.png)


![](/assets/img/2021-09-29-binary-only-fuzzing/real-world-binaries-eval.png)

The authors also evaluate ZAFLs' real-world coverage-tracing overhead against AFL-QEMU, AFL-Dyninst and the compiler/assembler-based instrumentation in baseline AFL. The results show that ZAFL achieves fuzzing performance on binary-only targets with an 'indistinguishable' overhead comparable to compiler-level performance.

![](/assets/img/2021-09-29-binary-only-fuzzing/overhead-eval.png)

When evaluating ZAFL on closed-source binaries against AFL-Dynist and AFL-QEMU, ZAFL notably finds crashes in certain targets that the other two do not.

![](/assets/img/2021-09-29-binary-only-fuzzing/closed-source-eval.png)

The authors also compare the time-to-discovery for five closed-source bugs found by the three fuzzing tools, noting that on average, ZAFL easily outperforms the other two fuzzers.

![](/assets/img/2021-09-29-binary-only-fuzzing/ttd-eval.png)

Lastly, the authors evaluate the scalability and precision of ZAFL on both Linux and Windows binaries, successfully instrumenting 33 open-source Linux/Windows binaries and 23 closed-source ones. Below is a breakdown of the binaries tested with ZAFL, showing cases where register liveness optimization succeeds:

![](/assets/img/2021-09-29-binary-only-fuzzing/scalability-eval-1.png)
![](/assets/img/2021-09-29-binary-only-fuzzing/scalability-eval-2.png)

To measure precision, the authors compare the percentage of false positive/negative instructions found via ZAFLs' instruction recovery mechanisms against state-of-the-art tools IDAPro7.1 and Binary Ninja 1.1.1259. The authors observe that ZAFL managed to maintain a 0% false negative rate for instruction recovery when evaluated against a 'ground-truth' disassembly of a binaries .TEXT section using objdump. To evaluate ZAL's control-flow recovery mechanism, its coverage accuracy is compared against a ground-truth LLVM-instrumented binary. The results below show that ZAFLs' coverage identification is near-identical to LLVMs'.

![](/assets/img/2021-09-29-binary-only-fuzzing/precision-eval-1.png)
![](/assets/img/2021-09-29-binary-only-fuzzing/precision-eval-2.png)

## Discussion
